# Report

## Chord

### 文件结构

- **`chord/chord.go`**: 实现了 chord 协议的核心功能，包括节点的创建、加入、退出，数据的插入、查找、删除，以及环结构的维护。
- **`chord/tool.go`**: 实现了哈希计算和数学计算等辅助功能。

### 实现方式

chord 协议通过一个环结构来存储和查找数据。每个节点和数据都有一个唯一的哈希值，从小到大在一个环上。节点负责存储其哈希值之后到下一个节点哈希值之间的所有数据。插入、查找、删除数据时，借助 finger list ，实现了高效的节点查找算法。为了处理并发的情况，chord 协议通过 stabilize 操作，维护环结构的稳定，以保证节点查找的正确性。同时，chord 协议会周期性地维护其 finger list ，以保证节点查找的效率。为应对节点突然失效的情况，节点会存储后继列表来防止后继突然失效，并备份多份数据来防止数据丢失。

### 细节&特征

* 在维护后继列表时，选择用后继的后继列表来更新当前节点的后继列表。如果每个节点的直接后继是正确的，在经过`len(后继列表)`轮的维护后，能确保每个节点的后继列表都是正确的。
* 在执行`Quit`函数时，需要修改当前节点前继的后继。如果此时当前节点及其前继后继节点的`Stabilize`进程仍在运行，可能无法保证`Quit`中执行的修改被正确执行，进而无法保证环结构的正确性。因此在`Quit`时需阻塞当前节点及其前继后继节点的`Stabilize`进程。
* 在`remoteCall`函数中，`Dial`成功并不能保证`Call`成功，因为client可能恰好在`Dial`执行之后，`Call`执行之前关闭了，所以`Call`也需要加上 timeout 。
* 应该在`Quit`和`ForceQuit`函数中就关闭监听器，而不是等接受到`quit` channel 中的信息再关闭，因为在这个短暂的时间间隔中可能会产生难以控制的结果。
* 每份数据备份在存储数据节点的后继节点上，在检测到节点异常退出时用备份数据恢复。如果一个节点后继列表前两个元素都异常退出了，说明部分数据丢失。
* 打印过多的日志会严重影响程序的运行速度，也会影响程序的运行结果。所以在调试的时候应该只打印一小部分日志，同时增大 timeout ，防止一些操作被意外中断。

## Kademlia

### 文件结构

**`kademlia/kademlia.go`**: 实现了 kademlia 协议的核心功能，包括节点的创建、加入、退出，数据的插入、查找、删除，以及网络结构的维护。

**`kademlia/data.go`**: 实现了数据结构体`Data`以及相关功能，包括丢弃、存储、查找数据等。

**`kademlia/tool.go`**: 实现了一些辅助函数，如哈希函数、链表操作和异或距离计算等，用于支持核心协议的实现。

### 实现方式

kademlia 协议使用XOR度量来定义节点之间的距离，数据存储在距离它最近的 k 个节点中。节点通过 k-buckets 维护与其他节点的联系，`bucket[i]`存储与当前节点距离在$\left(2^i - 1, 2^{i + 1}\right]$范围内的节点。在查找节点时，kademlia 协议通过并行查询多个节点来加速查找过程，逐步逼近目标。

### 细节&特征

* k-buckets 涉及大量插入、删除、移动节点的操作，因此选用链表作为存储结构，调用`container/list`包中 `list.List`类来实现。
* RPC方法中的参数必须导出的，这要求参数类型的成员变量也是导出的，因此其中所有的字段名都要大写。
* 在进行远程调用后，除了更新发起端的 k-buckets，还更新了接收端的 k-buckets，这样能让整个网络更充分地建立起联系。
* 要控制程序的并发量，在`republish`, `nodeLookup`等函数中，有大量的并发操作。需要通过设置合适的参数来避免并发量过大。
* 因为 kademlia 协议并发程度很高，相邻的上锁解锁之间前一次取出的临时变量可能再第二次上锁时就已经被改变。例如在`flush`中，在前一次上锁解锁取出的 bucket 的 size 在后一次上锁解锁时可能就不是真实值了，所以需要加大锁来避免这种情况。